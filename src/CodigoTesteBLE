#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLEClient.h>

// UUIDs  
const char* CIA_CONTROL_ENABLE = "22086d8b-57c2-4eb4-b82d-4b7936413e78";
const char* CONTROLE_TEMP     = "2f7d55d9-acce-4a1d-9871-dd3e4ec73eec";
const char* ENABLE_1          = "1b4a81b4-abf5-450d-9d4d-81b4e951baa7";
const char* ENABLE_2          = "d2b757c1-9fb1-4166-af83-467a0a0a55f3";
const char* ENABLE_3          = "765170c6-24e5-4890-a346-10195b57ca7c";
const char* AlTemp_1          = "28b66ce2-882e-46e2-bc17-1332f33072db";
const char* AlTemp_2          = "83ec522b-14b0-4b42-8a8b-0924993f5490";
const char* AlTemp_3          = "e49b8658-6f76-43dd-a36e-db7f4b1aa546";

const char* SERVICE_UUID[2] = { CIA_CONTROL_ENABLE, CONTROLE_TEMP };
const char* CHARACTERISTIC_UUID[6] = { ENABLE_1, ENABLE_2, ENABLE_3, AlTemp_1, AlTemp_2, AlTemp_3 };

// Variáveis de controle (simulação)
bool controleAtivo[3] = { false, false, false };
int setpoint[3]       = { 25, 25, 25 };

// ---------------------- Helpers ----------------------
static void printBytes(const std::string &value, const char* tag = nullptr) {
  if (tag) Serial.print(tag);
  Serial.printf(" [len=%u] bytes:", (unsigned)value.size());
  for (size_t i = 0; i < value.size(); ++i) {
    uint8_t b = static_cast<uint8_t>(value[i]);
    Serial.printf(" 0x%02X(%u)", b, b);
  }
  Serial.println();
}

// ---------------------- Classes BLE ----------------------
class enableServer : public BLEServerCallbacks {
  void onConnect(BLEServer* servidorCIA) override {
    Serial.println("[BLE] Dispositivo conectado!");
  }
  void onDisconnect(BLEServer* servidorCIA) override {
    Serial.println("[BLE] Dispositivo desconectado!");
  }
};

class enableControl : public BLECharacteristicCallbacks {
  bool &controle;
public:
  enableControl(bool &control) : controle(control) {}
  void onWrite(BLECharacteristic* ENABLE_CONTROL) override {
    const std::string value = ENABLE_CONTROL->getValue();

    if (!value.empty()) {
      // Print completo em bytes (hex + decimal)
      printBytes(value, "[BLE] enableControl recebido:");

      // Interpreta o primeiro byte como valor numérico (0 = off, !=0 = on)
      uint8_t b0 = static_cast<uint8_t>(value[0]);
      controle = (b0 != 0);

      Serial.printf("[BLE] enableControl - primeiro byte: 0x%02X (%u) -> controleAtivo=%s\n",
                    b0, b0, controle ? "ON" : "OFF");
    } else {
      Serial.println("[BLE] enableControl onWrite - valor vazio recebido");
    }
  }
};

class functionsControl : public BLECharacteristicCallbacks {
  int &set_point;
public:
  functionsControl(int &st) : set_point(st) {}
  void onWrite(BLECharacteristic* variaveisBLE) override {
    const std::string value = variaveisBLE->getValue();

    if (!value.empty()) {
      // Print completo em bytes (hex + decimal)
      printBytes(value, "[BLE] functionsControl recebido:");

      // Interpreta o primeiro byte como valor numérico (não ASCII)
      uint8_t b0 = static_cast<uint8_t>(value[0]);
      set_point = (int)b0;

      Serial.printf("[BLE] functionsControl - primeiro byte interpretado como valor: 0x%02X (%u) -> setpoint=%d\n",
                    b0, b0, set_point);
    } else {
      Serial.println("[BLE] functionsControl onWrite - valor vazio recebido");
    }
  }
  void onRead(BLECharacteristic* variaveisBLE) override {
    // Envia leitura em ASCII para leitura fácil via apps (mantive isso)
    std::string out = std::to_string(set_point);
    variaveisBLE->setValue(out);
    Serial.printf("[BLE] functionsControl leitura (ASCII): %s\n", out.c_str());
  }
};

// ---------------------- Setup ----------------------
void setup() {
  Serial.begin(115200);
  Serial.println("\n=== Iniciando ESP32S_CIA - Teste BLE ===");

  // Inicializa BLE uma vez
  BLEDevice::init("ESP32S_CIA");

  // === Print do endereço MAC ===
  BLEAddress mac = BLEDevice::getAddress();
  Serial.print("[INFO] Endereço MAC do ESP32: ");
  Serial.println(mac.toString().c_str());

  BLEServer *servidorCIA = BLEDevice::createServer();
  servidorCIA->setCallbacks(new enableServer());

  // Criação de serviços
  BLEService *controlTemp[2];
  for (int i = 0; i < 2; i++) {
    controlTemp[i] = servidorCIA->createService(SERVICE_UUID[i]);
    Serial.printf("[BLE] Serviço criado UUID: %s\n", SERVICE_UUID[i]);
  }

  // Criação de características
  BLECharacteristic *variaveisBLE[6];
  int k = 0, l = 0;
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      variaveisBLE[k] = controlTemp[i]->createCharacteristic(
        CHARACTERISTIC_UUID[l],
        BLECharacteristic::PROPERTY_READ   |
        BLECharacteristic::PROPERTY_WRITE  |
        BLECharacteristic::PROPERTY_NOTIFY |
        BLECharacteristic::PROPERTY_INDICATE
      );
      Serial.printf("[BLE] Característica criada UUID: %s\n", CHARACTERISTIC_UUID[l]);
      k++;
      l++;
    }
  }

  // Ativar callbacks
  for (int i = 0; i < 3; i++) {
    variaveisBLE[i]->setCallbacks(new enableControl(controleAtivo[i]));
  }
  for (int i = 3; i < 6; i++) {
    variaveisBLE[i]->setCallbacks(new functionsControl(setpoint[i - 3]));
  }

  // Iniciar serviços
  for (int i = 0; i < 2; i++) {
    controlTemp[i]->start();
    Serial.printf("[BLE] Serviço iniciado: %s\n", SERVICE_UUID[i]);
  }

  // Iniciar advertising (padrão)
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->setScanResponse(true); // ajuda descoberta
  pAdvertising->start();
  Serial.println("[BLE] Advertising iniciado. Aguardando conexão...");
}

// ---------------------- Loop ----------------------
// prints periódicos sem bloqueio
unsigned long lastSetpointPrint = 0;
const unsigned long setpointPrintInterval = 5000UL; // 5 segundos

unsigned long lastHeartbeatPrint = 0;
const unsigned long heartbeatInterval = 2000UL; // 2 segundos (opcional)

void loop() {
  unsigned long now = millis();

  // Print dos setpoints a cada 5 segundos
  if (now - lastSetpointPrint >= setpointPrintInterval) {
    lastSetpointPrint = now;
    Serial.printf("[SETPOINTS] Atuais -> zona1: %d | zona2: %d | zona3: %d\n",
                  setpoint[0], setpoint[1], setpoint[2]);
  }

  // Log heartbeat (opcional)
  if (now - lastHeartbeatPrint >= heartbeatInterval) {
    lastHeartbeatPrint = now;
    Serial.println("[LOG] Loop rodando - aguardando eventos BLE...");
  }

  // pequena pausa para evitar uso 100% CPU e dar tempo para outras tasks do sistema
  delay(10);
}
